import shared-enums;

Aggregate Execution  {
    Entity ExecutionCourse uses dto CourseDto mapping {
        aggregateId -> courseAggregateId;
        version -> courseVersion;
        type -> courseType;
        name -> courseName;
    } {
        Integer courseAggregateId;
        String courseName;
        CourseType courseType;
        Integer courseVersion;
    }

    Entity ExecutionUser uses dto UserDto mapping {
        aggregateId -> userAggregateId;
        version -> userVersion;
        state -> userState;
        name -> userName;
        username -> userUsername;
        active -> userActive;
    } {
        Integer userAggregateId;
        Integer userVersion;
        AggregateState userState;
        String userName;
        String userUsername;
        Boolean userActive;
    }

    Root Entity Execution {
        String acronym;
        String academicTerm;
        LocalDateTime endDate;
        ExecutionCourse course;
        Set<ExecutionUser> users;

        invariants {
           
        }


        methods {

        }
    }

    
    Repository {
        @Query("select e1.aggregateId from Execution e1 where e1.aggregateId NOT IN (select e2.aggregateId from Execution e2 where e2.state = 'DELETED' AND e2.sagaState != 'NOT_IN_SAGA')")
        Set<Integer> findCourseExecutionIdsOfAllNonDeletedForSaga();
    }

    Events {
        publish AnonymizeUserEvent {
            String name;
            String username;
            Integer userAggregateId;
        }

        publish UpdateStudentNameEvent {
            String oldName;
            String newName;
            Integer studentAggregateId;
        }

        publish DeleteExecutionEvent {
            Integer executionAggregateId;
            String acronym;
        }

        publish EnrollStudentInExecutionEvent {
            Integer executionAggregateId;
            Integer studentAggregateId;
            String studentName;
        }

        publish DisenrollStudentFromExecutionEvent {
            Integer executionAggregateId;
            Integer studentAggregateId;
            String studentName;
        }

        subscribe DeleteUserEvent from ExecutionUser {
            event.getUserAggregateId() == executionUser.getStudentAggregateId();
        }
    }

    WebAPIEndpoints {
        Endpoint CreateExecution {
            httpMethod: POST
            path: "/executions/create"
            methodName: createExecution
            parameters: [
                executionDto: Execution: "@RequestBody"
            ]
            returnType: Execution
            desc: "Create a new execution"
            throwsException: true
        }

        Endpoint GetExecutionByAggregateId {
            httpMethod: GET
            path: "/executions/{executionAggregateId}"
            methodName: getExecutionByAggregateId
            parameters: [
                executionAggregateId: Integer: "@PathVariable"
            ]
            returnType: Execution
            desc: "Get execution by aggregate ID"
            throwsException: false
        }

        Endpoint GetExecutions {
            httpMethod: GET
            path: "/executions"
            methodName: getExecutions
            returnType: List<Execution>
            desc: "Get all executions"
            throwsException: false
        }

        Endpoint RemoveExecution {
            httpMethod: POST
            path: "/executions/{executionAggregateId}/delete"
            methodName: removeExecution
            parameters: [
                executionAggregateId: Integer: "@PathVariable"
            ]
            desc: "Remove an execution"
            throwsException: true
        }

        Endpoint EnrollStudent {
            httpMethod: POST
            path: "/executions/{executionAggregateId}/students/add"
            methodName: addStudent
            parameters: [
                executionAggregateId: Integer: "@PathVariable",
                userAggregateId: Integer: "@RequestParam"
            ]
            desc: "Enroll a student in a course execution"
            throwsException: true
        }

        Endpoint GetUserExecutions {
            httpMethod: GET
            path: "/users/{userAggregateId}/executions"
            methodName: getExecutionsByUser
            parameters: [
                userAggregateId: Integer: "@PathVariable"
            ]
            returnType: Set<Execution>
            desc: "Get all executions for a user"
            throwsException: false
        }

        Endpoint RemoveStudentFromExecution {
            httpMethod: POST
            path: "/executions/{executionAggregateId}/students/remove"
            methodName: removeStudentFromExecution
            parameters: [
                executionAggregateId: Integer: "@PathVariable",
                userAggregateId: Integer: "@RequestParam"
            ]
            desc: "Remove a student from an execution"
            throwsException: true
        }

        Endpoint AnonymizeExecutionUser {
            httpMethod: POST
            path: "/executions/{executionAggregateId}/anonymize"
            methodName: anonymizeStudent
            parameters: [
                executionAggregateId: Integer: "@PathVariable",
                userAggregateId: Integer: "@RequestParam"
            ]
            desc: "Anonymize a student in an execution"
            throwsException: true
        }

        Endpoint UpdateExecutionUserName {
            httpMethod: POST
            path: "/executions/{executionAggregateId}/students/{userAggregateId}/update/name"
            methodName: updateStudentName
            parameters: [
                executionAggregateId: Integer: "@PathVariable",
                userAggregateId: Integer: "@PathVariable"
            ]
            desc: "Update student name in an execution"
            throwsException: true
        }
    }

    Service ExecutionService {
        @GenerateCrud;
        @Transactional;
        
        methods {
            removeUser(Integer executionAggregateId, Integer userAggregateId, Integer userVersion, UnitOfWork unitOfWork): Execution {
                load oldExecution = aggregate(executionAggregateId);
                create newExecution = Execution(oldExecution);
                execute newExecution.findStudent(userAggregateId).setState(INACTIVE);
                register newExecution in unitOfWork;
                registerEvent DisenrollStudentFromExecutionEvent(executionAggregateId, userAggregateId) in unitOfWork;
                return newExecution;
            }
            anonymizeStudent(Integer executionAggregateId, Integer userAggregateId, UnitOfWork unitOfWork): void;
            updateStudentName(Integer executionAggregateId, Integer userAggregateId, String newName, UnitOfWork unitOfWork): void;
        }
    }

    Functionalities {
        createExecution(Execution executionDto): Execution
        steps {
            sync createExecutionStep {
                call executionService.createExecution(executionDto, unitOfWork) assign to createdExecution;
                set result to ExecutionDto as getExecutionDto;
            }
        }
        ;
        
        getExecutionByAggregateId(Integer executionAggregateId): Execution
        steps {
            sync getExecutionStep {
                call executionService.getExecutionByAggregateId(executionAggregateId, unitOfWork) assign to executionDto;
                set result to ExecutionDto as getExecutionDto;
            }
        }
        ;
        
        getExecutions(): List<Execution>
        steps {
            sync getExecutionsStep {
                call executionService.getAllExecutions(unitOfWork) assign to executions;
                set result to ExecutionDto as getExecutions;
            }
        }
        ;
        
        removeExecution(Integer executionAggregateId): void
        steps {
            sync getExecutionStep {
                call executionService.getExecutionByAggregateId(executionAggregateId, unitOfWork) assign to courseExecution;
                register sagaState executionAggregateId as READ_COURSE in unitOfWork;
            }
            compensation {
                register sagaState executionAggregateId as NOT_IN_SAGA in unitOfWork;
            }
            
            sync removeExecutionStep depends on getExecutionStep {
                call executionService.removeExecution(executionAggregateId, unitOfWork);
            }
        }
        ;
        
        addStudent(Integer executionAggregateId, Integer userAggregateId): void
        dependencies { UserService }
        steps {
            sync getUserStep {
                call userService.getUserById(userAggregateId, unitOfWork) assign to userDto;
            }
            
            sync enrollStudentStep depends on getUserStep {
                call executionService.enrollStudent(executionAggregateId, userDto, unitOfWork);
            }
        }
        ;
        
        getExecutionsByUser(Integer userAggregateId): Set<Execution>
        steps {
            sync getExecutionsByUserStep {
                call executionService.getExecutionsByUser(userAggregateId, unitOfWork) assign to executions;
                set result to ExecutionDto as getExecutions;
            }
        }
        ;
        
        removeStudentFromExecution(Integer executionAggregateId, Integer userAggregateId): void
        steps {
            sync getExecutionStep {
                call executionService.getExecutionByAggregateId(executionAggregateId, unitOfWork) assign to oldExecution;
                register sagaState executionAggregateId as READ_COURSE in unitOfWork;
            }
            compensation {
                register sagaState executionAggregateId as NOT_IN_SAGA in unitOfWork;
            }
            
            sync removeStudentStep depends on getExecutionStep {
                call executionService.removeStudentFromExecution(executionAggregateId, userAggregateId, unitOfWork);
            }
        }
        ;
        
        anonymizeStudent(Integer executionAggregateId, Integer userAggregateId): void
        steps {
            sync getExecutionStep {
                call executionService.getExecutionByAggregateId(executionAggregateId, unitOfWork) assign to courseExecution;
                register sagaState executionAggregateId as READ_COURSE in unitOfWork;
            }
            compensation {
                register sagaState executionAggregateId as NOT_IN_SAGA in unitOfWork;
            }
            
            sync anonymizeStudentStep depends on getExecutionStep {
                call executionService.anonymizeStudent(executionAggregateId, userAggregateId, unitOfWork);
            }
        }
        ;
        
        updateStudentName(Integer executionAggregateId, Integer userAggregateId, String newName): void
        steps {
            sync updateStudentNameStep {
                call executionService.updateStudentName(executionAggregateId, userAggregateId, newName, unitOfWork);
            }
        }
        ;
    }
}
