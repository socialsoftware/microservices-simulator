import shared-dtos;

Aggregate Answer {
    Entity AnswerUser uses dto UserDto mapping {
        aggregateId -> userAggregateId;
        name -> userName;
        state -> userState;
    } {
        Long id;
        Integer userAggregateId;
        String userName;
        AggregateState userState;
    }

    Entity AnswerExecution uses dto ExecutionDto mapping {
        aggregateId -> executionAggregateId;
        version -> executionVersion;
    } {
        Long id;
        Integer executionAggregateId;
        Integer executionVersion;
    }

    Entity AnswerQuestion uses dto QuestionDto mapping {
        aggregateId -> questionAggregateId;
        sequence -> questionOptionSequenceChoice;
        optionKey -> questionOptionKey;
    } {
        Long id;
        Integer questionAggregateId;
        Integer questionVersion;
        AggregateState questionState;
        Integer questionOptionSequenceChoice;
        Integer questionTimeTaken;
        Integer questionOptionKey;
        Boolean questionCorrect;
    }

    Entity AnswerQuiz uses dto QuizDto mapping {
        aggregateId -> quizAggregateId;
        version -> quizVersion;
        questions -> quizQuestionsAggregateIds extract aggregateId;
    } {
        Long id;
        Integer quizAggregateId;
        Integer quizVersion;
        List<Integer> quizQuestionsAggregateIds;
    }

    Root Entity Answer {
        LocalDateTime creationDate;
        LocalDateTime answerDate;
        Boolean completed;
        AnswerExecution answerExecution;
        AnswerUser answerUser;
        AnswerQuiz answerQuiz;
        List<AnswerQuestion> answerQuestion;

        invariants {

        }


        methods {
   
        }
    }

    // Service methods
    method getAnswersByExecution(Integer executionId, UnitOfWork unitOfWork): List<Answer>;
    method getAnswersByStudentAndExecution(Integer studentId, Integer executionId, UnitOfWork unitOfWork): List<Answer>;
    method getAnswersByQuizAndExecution(Integer quizId, Integer executionId, UnitOfWork unitOfWork): List<Answer>;
    
    // Event processing workflows
    saga workflow anonymizeStudent(Integer studentAggregateId, Integer answerId, UnitOfWork unitOfWork);
    saga workflow invalidateQuiz(Integer quizAggregateId, Integer answerId, UnitOfWork unitOfWork);
    saga workflow removeExecution(Integer executionAggregateId, Integer answerId, UnitOfWork unitOfWork);
    saga workflow unenrollStudentFromExecution(Integer studentAggregateId, Integer executionAggregateId, Integer answerId, UnitOfWork unitOfWork);
    saga workflow updateStudentName(Integer studentAggregateId, String studentName, String studentUsername, Integer answerId, UnitOfWork unitOfWork);
    
    CustomRepository {
        Optional<Integer> findAnswerIdByAnswerQuizQuizAggregateIdAndAnswerUserUserAggregateId(Integer quizAggregateId, Integer studentAggregateId);
    }

    WebAPIEndpoints {
        Endpoint AnswerQuestion {
            httpMethod: POST
            path: "/quizzes/{quizAggregateId}/answer"
            methodName: answerQuestion
            parameters: [
                quizAggregateId: Integer: "@PathVariable",
                userAggregateId: Integer: "@RequestParam",
                questionAnswerDto: Answer: "@RequestBody"
            ]
            desc: "Submit an answer to a quiz question"
            throwsException: true
        }
    }

    Service AnswerService {
        @GenerateCrud;
        @Transactional;
        methods {
            createAnswer(Answer answer, Integer userId): Answer;
            findAnswerById(Integer id): Answer;
            updateAnswerState(Integer id, AggregateState state): Answer;
            deleteAnswer(Integer id): void;
            findAnswersByStudent(Integer studentId): List<Answer>;
        }
    }
}
