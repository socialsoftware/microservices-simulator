Aggregate Answer {
    Entity AnswerUser uses dto UserDto mapping {
        aggregateId -> userAggregateId;
        name -> userName;
        state -> userState;
    } {
        Integer userAggregateId;
        String userName;
        AggregateState userState;
    }

    Entity AnswerExecution uses dto ExecutionDto mapping {
        aggregateId -> executionAggregateId;
        version -> executionVersion;
    } {
        Integer executionAggregateId;
        Integer executionVersion;
    }

    Dto Entity QuestionAnswered {
        Integer sequence;
        Integer key;
        Integer timeTaken;
        Boolean correct;
        Integer questionAggregateId;
        Integer questionVersion;
        AggregateState state default AggregateState.ACTIVE;
    }

    Entity AnswerQuiz uses dto QuizDto mapping {
        aggregateId -> quizAggregateId;
        version -> quizVersion;
        questions -> quizQuestionsAggregateIds extract aggregateId;
    } {
        Integer quizAggregateId;
        Integer quizVersion;
        List<Integer> quizQuestionsAggregateIds;
    }

    Root Entity Answer {
        LocalDateTime creationDate;
        LocalDateTime answerDate;
        Boolean completed;
        AnswerExecution execution;
        AnswerUser user;
        AnswerQuiz quiz;
        List<QuestionAnswered> questions;
    }

   
    Repository {
        @Query("select a.aggregateId from Answer a where a.quiz.quizAggregateId = :quizAggregateId AND a.user.userAggregateId = :userAggregateId AND a.sagaState = 'NOT_IN_SAGA'")
        Optional<Integer> findAnswerIdByQuizAggregateIdAndUserAggregateIdForSaga(Integer quizAggregateId, Integer userAggregateId);
    }

    WebAPIEndpoints {
        @GenerateCrud;
    }

    Service AnswerService {
        @GenerateCrud;   
    }
}
