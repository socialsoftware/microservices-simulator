Aggregate Answer {
    Entity AnswerUser uses dto UserDto {
        Integer userAggregateId -> aggregateId;
        String userName -> name;
        AggregateState userState -> state;
    }

    Entity AnswerExecution uses dto ExecutionDto {
        Integer executionAggregateId -> aggregateId;
        Integer executionVersion -> version;
    }

    Dto Entity QuestionAnswered {
        Integer sequence;
        Integer key;
        Integer timeTaken;
        Boolean correct;
        Integer questionAggregateId;
        Integer questionVersion;
        AggregateState state default AggregateState.ACTIVE;
    }

    Entity AnswerQuiz uses dto QuizDto {
        Integer quizAggregateId -> aggregateId;
        Integer quizVersion -> version;
        List<Integer> quizQuestionsAggregateIds -> questions extract aggregateId;
    }

    Root Entity Answer {
        LocalDateTime creationDate;
        LocalDateTime answerDate;
        Boolean completed;
        AnswerExecution execution;
        AnswerUser user;
        AnswerQuiz quiz;
        List<QuestionAnswered> questions;
    }

   
    Repository {
        @Query("select a.aggregateId from Answer a where a.quiz.quizAggregateId = :quizAggregateId AND a.user.userAggregateId = :userAggregateId AND a.sagaState = 'NOT_IN_SAGA'")
        Optional<Integer> findAnswerIdByQuizAggregateIdAndUserAggregateIdForSaga(Integer quizAggregateId, Integer userAggregateId);
    }

    WebAPIEndpoints {
        @GenerateCrud;
    }

    Service AnswerService {
        @GenerateCrud;   
    }
}
